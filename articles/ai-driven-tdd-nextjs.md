---
title: "OSS記憶保持ツールと実践する「AI駆動テスト開発」〜AIをプロジェクトの専門家にする方法〜"
emoji: "🤖"
type: "tech"
topics: ["Nextjs", "TypeScript", "Jest", "AI", "TDD"]
published: false # 公開する準備ができたら true にする
---

OSS記憶保持ツールと実践する「AI駆動テスト開発」〜AIをプロジェクトの専門家にする方法〜
はじめに
「このAI、さっき伝えたこともう忘れてる…」

AIを開発に利用したことがある方なら、一度はこう感じたことがあるのではないでしょうか。AIアシスタントは強力ですが、対話の文脈をすぐに忘れてしまうため、プロジェクト全体のパートナーとして活用するには限界がありました。

この課題を解決するため、本プロジェクトではAIにプロジェクトの仕様や構造を記憶させるオープンソースの記憶保持ツールCipherを導入。AIを「自己学習」させ、プロジェクトの専門家へと育てることで、AI駆動テスト開発（AITDD） のワークフローを構築しました。

この記事では、OSSを活用してAIの記憶問題をどう解決し、それによって開発体験がどう変わったのかを共有します。

開発したリポジトリはこちらです。
https://github.com/s977043/digital-omikuji-aitdd

本プロジェクトの核心：なぜ「自己学習」が重要なのか？
従来のAI支援開発では、開発者がその都度AIにコンテキスト（前提情報）を与える必要がありました。これは非常に手間がかかり、AIの応答も表層的なものになりがちです。

そこで私たちは、この課題を解決するオープンソースの記憶保持ツール「Cipher」を導入しました。

記憶保持ツール「Cipher」の役割
Cipherは、AIに長期的な記憶を持たせるためのプロトコルサーバーとして機能するOSSです。

役割: プロジェクトの仕様書、ファイル構造、過去の決定事項などをAIに記憶させる。

効果: 開発のどの段階でも、AIはプロジェクト全体の文脈を理解した上で応答を返す。これにより、AIは単なるツールから、プロジェクトと共に成長するパートナーへと進化します。

この「自己学習」能力こそが、効率的なAITDDを実現するための鍵となります。

AI駆動テスト開発（AITDD）への応用
自己学習によってプロジェクトの「専門家」となったAIは、TDDのプロセスで絶大な効果を発揮します。

Red: 仕様を深く理解しているため、エッジケースまで考慮した精度の高いテストコードを生成できる。

Green: 生成されたテストの意図を汲み取り、仕様に沿ったプロダクションコードを的確に実装できる。

Refactor: プロジェクト全体の設計思想を踏まえた、質の高いリファクタリング案を提示できる。

自己学習AIとの開発ワークフロー
それでは、実際にどのように開発を進めたかを見ていきましょう。

Step 1: 環境構築と役割定義
まず、プロジェクトの骨格を定義します。この時点から、AIに学習させるためのドキュメントを意識して作成することが重要です。

# リポジトリをクローン
gh repo clone s977043/digital-omikuji-aitdd
cd digital-omikuji-aitdd

特にdocs/SPEC.md（仕様書）は、AIの教科書となる最も重要なファイルです。

Step 2: AIにプロジェクトを「自己学習」させる
ここが本ワークフローの最重要ステップです。OSSツールであるCipherサーバーを起動し、Gemini CLIを通じてプロジェクトの情報をAIに記憶させます。

# 記憶調整プロトコルサーバーを起動
./run_cipher_server.sh &

# geminiコマンドでプロジェクトの文脈をAIに記憶させる
gemini "このプロジェクトの全体構造と docs/SPEC.md の内容を分析し、今後の開発のために記憶してください。これはPythonで実装するおみくじアプリです。"

このコマンド一つで、AIはプロジェクトの専属アシスタントとなり、以降の対話の質が劇的に向上します。

Step 3: AITDDサイクルで開発を加速
AIがプロジェクトを完全に理解した状態で、TDDサイクルを回します。

1. Red (失敗するテストの生成)

👤 User's Prompt (to Gemini CLI)
docs/SPEC.md に基づいて、omikuji.py に実装する draw_omikuji 関数のテストを pytest で書いて。

2. Green (テストをパスするコードの生成)

👤 User's Prompt (to Gemini CLI)
先ほどのテストをパスするための draw_omikuji 関数を実装して。

自己学習のおかげで、プロンプトは非常にシンプルになります。AIは仕様書の内容を覚えているため、「どの運勢を返すか」などを細かく指示する必要はありません。

Step 4: AIと共にリファクタリング
最後に、AIにコードの改善案を求めます。

👤 User's Prompt (to Gemini CLI)
omikuji.py のコードを、よりクリーンで効率的な形にリファクタリングする提案をしてください。

ここでもAIはプロジェクトの全体像を把握しているため、場当たり的ではない、一貫性のある提案をしてくれます。

まとめ：AI開発は「育てる」時代へ
本プロジェクトを通じて、AIは単に「使う」だけの存在から、プロジェクトの文脈を「学習」させ「育てる」パートナーへと変貌を遂げました。

適切なOSS（今回はCipher）を見つけ出し、導入することで、AIの弱点であった記憶問題を解決し、その能力を最大限に引き出すことができました。

AIに定型作業や思考の補助を任せ、私たちはより創造的な作業や、どのツールをどう活用するかといったアーキテクチャの意思決定に集中する。この「人間とAIの新しい関係性」こそが、これからのソフトウェア開発のスタンダードになっていくのかもしれません。

本プロジェクトの詳細はこちらのリポジトリでご覧いただけます。
https://github.com/s977043/digital-omikuji-aitdd
